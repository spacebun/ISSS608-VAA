---
title: "Hands-on Exercise 5c"
subtitle: "Visual Multivariate Analysis: Heatmap for Visualising and Analysing Multivariate Data"
date: February 4, 2024
date-modified: "last-modified"
format:
  html:
    toc: true
    number-sections: true
    code-line-numbers: true
    
execute: 
  eval: true
  echo: true
  warning: false  
---

# **Heatmap for Visualising and Analysing Multivariate Data**

## Overview

Here I practice plotting static and interactive heatmap for visualising and analysing multivariate data.

## Loading libraries

```{r}
pacman::p_load(seriation, dendextend, heatmaply, tidyverse)
```

## Import and prepare data

### Importing data

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

Change the rows by country name instead of row number: The row number has been replaced into the country name.

```{r}
row.names(wh) <- wh$Country
```

Then the dataframe is transformed into a data matrix (R Matrix format).

```{r}
wh1 <- dplyr::select(wh, c(3, 7:12))
wh_matrix <- data.matrix(wh)
```

## **Static Heatmap**

There are many packages that can be used to draw heatmaps:

-   [heatmap()](https://www.rdocumentation.org/packages/stats/versions/3.6.0/topics/heatmap)of R stats package. It draws a simple heatmap.

-   [heatmap.2()](https://www.rdocumentation.org/packages/gplots/versions/3.0.1.1/topics/heatmap.2) of **gplots** R package. It draws an enhanced heatmap compared to the R base function.

-   [pheatmap()](https://www.rdocumentation.org/packages/pheatmap/versions/1.0.12/topics/pheatmap) of [**pheatmap**](https://www.rdocumentation.org/packages/pheatmap/versions/1.0.12) R package. **pheatmap** package also known as Pretty Heatmap. The package provides functions to draws pretty heatmaps and provides more control to change the appearance of heatmaps.

-   [**ComplexHeatmap**](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html) package of R/Bioconductor package. The package draws, annotates and arranges complex heatmaps (very useful for genomic data analysis). The full reference guide of the package is available [here](https://jokergoo.github.io/ComplexHeatmap-reference/book/).

-   [**superheat**](https://cran.r-project.org/web/packages/superheat/) package: A Graphical Tool for Exploring Complex Datasets Using Heatmaps. A system for generating extendable and customizable heatmaps for exploring complex datasets, including big data and data with multiple data types. The full reference guide of the package is available [here](https://rlbarter.github.io/superheat/).

For this exercise we will learn how to use `heatmap()` of R Stats package.

### `heatmap` of *R Stats*

By default, **heatmap()** plots a cluster heatmap. The arguments ***Rowv=NA*** and ***Colv=NA*** are used to switch off the option of plotting the row and column dendrograms.

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      Rowv=NA, Colv=NA)
```

To plot a cluster heatmap, we just have to use the default as shown in the code chunk below.

Note that the heatmap does a reordering using clusterisation: it calculates the distance between each pair of rows and columns and try to order them by similarity. Moreover, the corresponding dendrogram are provided beside the heatmap.

```{r}
wh_heatmap <- heatmap(wh_matrix)
```

To make the heatmap more informative, we need to perform normalization with `scale` argument. This is because some of the Happiness Score variables have relatively higher values, what makes that the other variables with small values all look the same.

We normalise the matrix column-wise. Also note that **margins** argument is used to ensure that the entire x-axis labels are displayed completely and, cexRow and cexCol arguments are used to define the font size used for y-axis and x-axis labels respectively.

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      scale="column",
                      cexRow = 0.6, 
                      cexCol = 0.8,
                      margins = c(10, 4))
```

## **Interactive Heatmap**

We use [**heatmaply**](http://talgalili.github.io/heatmaply/) to build interactive cluster heatmap that can be shared online as a standalone html file.

Read the [Introduction to Heatmaply](#0) and its [user manual](https://cran.r-project.org/web/packages/heatmaply/heatmaply.pdf) to have an overall understanding of the features and functions of Heatmaply package.

### **Working with heatmaply**

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)]) 
```

### **Data transformation**

When analysing multivariate data set, it is very common that the variables in the data sets includes values that reflect different types of measurement. In general, these variables’ values have their own range. In order to ensure that all the variables have comparable values, data transformation are commonly used before clustering.

Three main data transformation methods are supported by *heatmaply()*, namely: scale, normalise and percentize.

#### Scaling method

-   When all variables are came from or assumed to come from some normal distribution, then scaling (i.e.: **subtract the mean and divide by the standard deviation**) would bring them all close to the standard normal distribution.

-   In such a case, each value would reflect the distance from the mean in units of standard deviation.

-   The *scale* argument in *heatmaply()* supports column and row scaling.

The code chunk below is used to scale variable values columewise.

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)],
          scale = "column")
```

#### Normalising method

-   When variables in the data comes from possibly different (and non-normal) distributions, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations.

-   This preserves the shape of each variable’s distribution while making them easily comparable on the same “scale”.

Different from Scaling, the normalise method is performed on the input data set i.e. wh_matrix as shown in the code chunk below.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))
```

#### Percentize method

-   This is similar to ranking the variables, but instead of keeping the rank values, divide them by the maximal rank.

-   This is done by using the ecdf of the variables on their own values, bringing each value to its empirical percentile.

-   The benefit of the percentize function is that each value has a relatively clear interpretation, it is the percent of observations that got that value or below it.

Similar to Normalize method, the Percentize method is also performed on the input data set i.e. wh_matrix as shown in the code chunk below.

```{r}
heatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))
```

### **Clustering algorithm**

**heatmaply** supports a variety of hierarchical clustering algorithm. The main arguments provided are:

-   *distfun*: function used to compute the distance (dissimilarity) between both rows and columns. Defaults to dist. The options “pearson”, “spearman” and “kendall” can be used to use correlation-based clustering, which uses as.dist(1 - cor(t(x))) as the distance metric (using the specified correlation method).

-   *hclustfun*: function used to compute the hierarchical clustering when *Rowv* or *Colv* are not dendrograms. Defaults to *hclust*.

-   *dist_method* default is NULL, which results in “euclidean” to be used. It can accept alternative character strings indicating the method to be passed to distfun. By default *distfun* is “dist”” hence this can be one of “euclidean”, “maximum”, “manhattan”, “canberra”, “binary” or “minkowski”.

-   *hclust_method* default is NULL, which results in “complete” method to be used. It can accept alternative character strings indicating the method to be passed to *hclustfun*. By default hclustfun is hclust hence this can be one of “ward.D”, “ward.D2”, “single”, “complete”, “average” (= UPGMA), “mcquitty” (= WPGMA), “median” (= WPGMC) or “centroid” (= UPGMC).

In general, a clustering model can be calibrated either manually or statistically.

#### Manual Approach

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "ward.D")
```

#### **Statistical Approach**

In order to determine the best clustering method and number of cluster the *dend_expend()* and *find_k()* functions of **dendextend** package will be used.

First, the *dend_expend()* will be used to determine the recommended clustering method to be used.

```{r}
wh_d <- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = "euclidean")
dend_expend(wh_d)[[3]]
```

The output table shows that “average” method should be used because it gave the high optimum value.

Next, *find_k()* is used to determine the optimal number of cluster.

```{r}
wh_clust <- hclust(wh_d, method = "average")
num_k <- find_k(wh_clust)
plot(num_k)
```

Figure above shows that k=3 would be good.

With reference to the statistical analysis results, we can prepare the code chunk as shown below.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "average",
          k_row = 3)
```

### **Seriation**

Hierarchical clustering doesn’t actually place the rows in a definite order, it merely constrains the space of possible orderings.

**heatmaply** uses the seriation package to find an optimal ordering of rows and columns. Optimal means to optimize the Hamiltonian path length that is restricted by the dendrogram structure. This, in other words, means to rotate the branches so that the sum of distances between each adjacent leaf (label) will be minimized.

-   "OLO": Optimal leaf ordering optimizes the above criterion (in O(n\^4))

-   "GW" Gruvaeus and Wainer heuristic to optimize the Hamiltonian path length that is restricted by the dendrogram structure

-   "mean": sorts the matrix based on the reorderfun using marginal means of the matrix

-   "none"

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "OLO")
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "GW")
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "mean")
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none")
```

### **Working with colour palettes**

Vary the color palette using *colors* argument.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none",
          colors = Blues)
```

### **The finishing touch**

Beside providing a wide collection of arguments for meeting the statistical analysis needs, *heatmaply* also provides many plotting features to ensure cartographic quality heatmap can be produced.

In the code chunk below the following arguments are used:

-   *k_row* is used to produce 5 groups.

-   *margins* is used to change the top margin to 60 and row margin to 200.

-   *fontsizw_row* and *fontsize_col* are used to change the font size for row and column labels to 4.

-   *main* is used to write the main title of the plot.

-   *xlab* and *ylab* are used to write the x-axis and y-axis labels respectively.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          Colv=NA,
          seriate = "none",
          colors = Blues,
          k_row = 5,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="World Happiness Score and Variables by Country, 2018 \nDataTransformation using Normalise Method",
          xlab = "World Happiness Indicators",
          ylab = "World Countries"
          )
```

# References

-   [**R for Visual Analytics: Heatmap for Visualising and Analysing Multivariate Data**](https://r4va.netlify.app/chap14)
